<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Detectified</title>
<link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@100;400;700&display=swap" rel="stylesheet" />
<style>
/* === layout / style kept from your original site === */
body {
    margin: 0;
    font-family: "Exo 2", sans-serif;
    background: url("https://i.imgur.com/ol1MfVj.gif") no-repeat center center fixed;
    background-size: cover;
    cursor: url('https://i.imgur.com/4b7KkzM.png') 16 16, auto;
    color: black;
}

.fluidjumbo {
    background-color: #38e3be2f;
    backdrop-filter: blur(10px);
    padding: 25px;
    border-radius: 25px;
    text-align: center;
    margin: 20px auto;
    max-width: 90%;
}

.cards-container {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
    justify-items: center;
    padding: 10px;
}

.card {
    background: linear-gradient(rgba(229, 235, 234, 0.5), rgba(143, 143, 143, 0.5));
    border: 3px inset #ffffff9a;
    border-radius: 25px;
    width: 90%;
    max-width: 500px;
    text-align: center;
    padding: 15px;
    box-shadow: 0 0 30px #38e3be;
    backdrop-filter:blur(5px);
}

.img-wrap {
    display: inline-block;
    transition: transform 0.4s ease;
}

.img-wrap:hover {
    transform: rotate(360deg) scale(1.1);
}

.card img {
    width: 200px;
    height: 200px;
    border-radius: 30px;
    display: block;
}

button {
    display: block;
    margin: 10px auto 0;
    border-radius: 25px;
    padding: 8px 20px;
    border: 2px solid #38e3be;
    background: rgba(255, 255, 255, 0.2);
    cursor: pointer;
    transition: 0.3s ease;
}

button:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px #38e3be;
}

button.playing {
    box-shadow: 0 0 20px #38e3be;
}

/* visualizer canvas - hidden by default */
.visualizer {
    width: 100%;
    height: 60px;
    display: none;
    margin-top: 10px;
}

/* Modal */
.modal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.7);
    justify-content: center;
    align-items: center;
}

.modal-content {
    background: white;
    padding: 20px;
    border-radius: 15px;
    max-width: 400px;
}

/* responsive */
@media (max-width: 768px) {
    .cards-container { grid-template-columns: 1fr; }
    .card img { width: 150px; height: 150px; }
}

/* === New Additions === */
/* Sticky notes for Easter eggs */
.sticky-note {
  position: fixed;
  bottom: 10px;
  left: 10px;
  background: #fff9c4;
  color: #333;
  padding: 10px;
  border-radius: 8px;
  box-shadow: 2px 2px 8px rgba(0,0,0,0.2);
  font-family: "Exo 2", sans-serif;
  cursor: pointer;
  z-index: 10000;
  max-width: 200px;
}

/* Second sticky note */
.sticky-note#note2 { left: 220px; }

/* Particle background canvas */
#particle-canvas {
  position: fixed;
  top:0; left:0;
  width:100%; height:100%;
  pointer-events: none;
  z-index: -1;
}

/* Card flip effect */
.card.flip {
  transform: rotateY(180deg);
  transition: transform 0.6s;
  transform-style: preserve-3d;
}

/* Card inner content for flip */
.card .card-front, .card .card-back {
  backface-visibility: hidden;
  display: block;
}
.card .card-back {
  transform: rotateY(180deg);
  position: absolute;
  top:0; left:0;
  width: 100%; height: 100%;
  background: rgba(255,255,255,0.9);
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Disable animations class */
.no-animations * {
  transition: none !important;
  animation: none !important;
}
</style>
</head>
<body>

<div class="fluidjumbo">
    <h1>The (maybe detective) seal's portfolio</h1>
    <p>About me is below</p>
</div>

<div class="cards-container">

    <div class="card race">
        <h2>Racing / Driving / Cars</h2>
        <p>I like going racing like vroom vroom.</p>
        <div class="img-wrap"><img src="https://upload.wikimedia.org/wikipedia/commons/5/57/Global_MX-5_Cup_car_-_Tokyo_Auto_Salon_2015.jpg" alt="car"></div>
        <button class="open-modal" data-modal="modal1">Racing series I like</button>
    </div>

    <div class="card seal">
        <h2>Seals</h2>
        <p>If you can't tell, I like seals :)</p>
        <div class="img-wrap"><img src="niko.webp" alt="seal"></div>
        <button class="open-modal" data-modal="modal2">Seals of choosing</button>
    </div>

    <div class="card seal2">
        <h2>Seal 2</h2>
        <p>Seals and seals and seals...</p>
        <div class="img-wrap"><img src="niko.webp" alt="seal2"></div>
        <button class="open-modal" data-modal="modal3">Seals :)</button>
    </div>

<div class="card music">
  <h2>Music</h2>
  <p>Funny music I like</p>

  <div id="playlist-container">
    <button class="play-btn" data-audio="song1" data-vis="viz1">Play / Pause Finale</button>
    <canvas class="visualizer" id="viz1"></canvas>

    <button class="play-btn" data-audio="song2" data-vis="viz2">Play / Pause Funky Town</button>
    <canvas class="visualizer" id="viz2"></canvas>

    <!-- NEW SONG -->
    <button class="play-btn" data-audio="song3" data-vis="viz3">Play / Pause Nope your too late ive already died</button>
    <canvas class="visualizer" id="viz3"></canvas>
  </div>
</div>


</div>

<!-- Modals -->
<div id="modal1" class="modal"><div class="modal-content"><p>Some racing thingys i like (series) are Nascar (NO ITS NOT JUST CARS GOING IN CIRCLES) F1, GT3, WEC, WRC, Endurance etc etc rx7 fc</p><button class="close-modal">Close</button></div></div>
<div id="modal2" class="modal"><div class="modal-content"><p>so like theres many species of seals, like the um, the um erm um species. Harp Ringed Harbor, Monk, theres more if u want to search it up </p><button class="close-modal">Close</button></div></div>
<div id="modal3" class="modal"><div class="modal-content"><p>niko (in my opinion) is the best seal, followed by kroshik, then yuki, then yo-chan, but all seals are COOL</p><button class="close-modal">Close</button></div></div>

<!-- Audio elements -->
<audio id="song1" src="finale.mp3" preload="auto"></audio>
<audio id="song2" src="funky.mp3" preload="auto"></audio>
<audio id="song3" src="nope.mp3" preload="auto"></audio>


<!-- Sticky notes -->
<div class="sticky-note" id="note1">Made by TheDetectiveSeal</div>
<div class="sticky-note" id="note2">i like seals</div>

<!-- No animations toggle -->
<button id="toggle-animations" style="position:fixed;top:10px;right:10px;z-index:10001;">No animations</button>

<!-- Particle background -->
<canvas id="particle-canvas"></canvas>

<script>
(() => {
  // --- Existing music/playback code remains untouched ---
  const playBtns = document.querySelectorAll('.play-btn');
  const canvases = {};
  document.querySelectorAll('.visualizer').forEach(c => canvases[c.id] = c);

  let audioCtx = null;
  let currentSource = null;
  let currentAnalyser = null;
  let currentCanvas = null;
  let drawRaf = null;
  let isPlaying = false;

  async function ensureAudioContext() {
    if (!audioCtx || audioCtx.state === 'closed') {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') {
      try { await audioCtx.resume(); } catch {}
    }
    return audioCtx;
  }

  function stopCurrent() {
    if (currentSource) {
      try { currentSource.stop(0); } catch {}
      try { currentSource.disconnect(); } catch {}
      currentSource = null;
    }
    if (currentAnalyser) {
      try { currentAnalyser.disconnect(); } catch {}
      currentAnalyser = null;
    }
    if (drawRaf) {
      cancelAnimationFrame(drawRaf);
      drawRaf = null;
    }

    document.querySelectorAll('.visualizer').forEach(c => c.style.display = 'none');
    document.querySelectorAll('.play-btn').forEach(b => b.classList.remove('playing'));
    isPlaying = false;
  }

  function prepareCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(rect.width * ratio));
    canvas.height = Math.max(1, Math.floor(rect.height * ratio));
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    return ctx;
  }

  function drawCenteredBars(analyser, canvas) {
    const ctx = prepareCanvas(canvas);
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    let hue = 0;

    function loop() {
      drawRaf = requestAnimationFrame(loop);
      analyser.getByteFrequencyData(dataArray);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const barWidth = 10;
      const gap = 5;
      const totalWidth = bufferLength * (barWidth + gap);
      const startX = (canvas.width / (window.devicePixelRatio || 1) - totalWidth) / 2;
      let x = startX;

      hue = (hue + 1) % 360;

      // Check if hovering
      const isHovered = canvas.matches(':hover');

      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i];
        const h = (v / 255) * (canvas.height / (window.devicePixelRatio || 1) - 8);

        if (isHovered) {
          ctx.fillStyle = `hsl(${(hue + i * 20) % 360}, 100%, 50%)`;
        } else {
          ctx.fillStyle = '#38e3be';
        }

        ctx.fillRect(x, (canvas.height / (window.devicePixelRatio || 1)) - h - 2, barWidth, h);
        x += barWidth + gap;
      }
    }

    loop();
}


  async function fetchAndPlay(url, button, canvas) {
    try {
      await ensureAudioContext();
      const res = await fetch(url, { cache: 'no-cache' });
      if (!res.ok) throw new Error(`Fetch HTTP ${res.status}`);
      const arrayBuffer = await res.arrayBuffer();
      const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

      stopCurrent();

      const src = audioCtx.createBufferSource();
      const analyser = audioCtx.createAnalyser();
      analyser.fftSize = 32;

      src.buffer = audioBuffer;
      src.connect(analyser);
      analyser.connect(audioCtx.destination);

      document.querySelectorAll('.play-btn').forEach(b => b.classList.remove('playing'));
      button.classList.add('playing');

      document.querySelectorAll('.visualizer').forEach(c => c.style.display = 'none');
      canvas.style.display = 'block';

      src.start(0);
      currentSource = src;
      currentAnalyser = analyser;
      isPlaying = true;
      currentCanvas = canvas;

      drawCenteredBars(analyser, canvas);

      src.onended = () => stopCurrent();
      return true;
    } catch (err) {
      console.error('fetchAndPlay error:', err);
      return false;
    }
  }

  async function fallbackPlay(audioEl, button, canvas) {
    try {
      await ensureAudioContext();
      if (!audioEl._elSource) {
        const src = audioCtx.createMediaElementSource(audioEl);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 64;
        src.connect(analyser);
        analyser.connect(audioCtx.destination);
        audioEl._elSource = { src, analyser };
      }

      stopCurrent();
      document.querySelectorAll('.visualizer').forEach(c => c.style.display = 'none');
      canvas.style.display = 'block';
      document.querySelectorAll('.play-btn').forEach(b => b.classList.remove('playing'));
      button.classList.add('playing');

      await audioEl.play();

      if (audioEl._elSource.analyser) {
        currentAnalyser = audioEl._elSource.analyser;
        drawCenteredBars(currentAnalyser, canvas);
      }

      isPlaying = true;
      currentCanvas = canvas;

      audioEl.onended = () => stopCurrent();
      return true;
    } catch (err) {
      console.error('fallbackPlay error:', err);
      return false;
    }
  }

  playBtns.forEach(btn => {
    btn.addEventListener('click', async () => {
      const audioId = btn.dataset.audio;
      const visId = btn.dataset.vis;
      const audioEl = document.getElementById(audioId);
      const canvas = document.getElementById(visId);

      if (isPlaying && currentCanvas === canvas) {
        stopCurrent();
        return;
      }

      const url = audioEl.src;
      let ok = await fetchAndPlay(url, btn, canvas);
      if (!ok) await fallbackPlay(audioEl, btn, canvas);
    });
  });

  document.querySelectorAll('.visualizer').forEach(c => c.style.display = 'none');

  // modal handling
  document.querySelectorAll('.open-modal').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.dataset.modal;
      const m = document.getElementById(id);
      if (m) m.style.display = 'flex';
    });
  });
  document.querySelectorAll('.close-modal').forEach(btn => {
    btn.addEventListener('click', () => {
      const m = btn.closest('.modal');
      if (m) m.style.display = 'none';
    });
  });
  window.addEventListener('click', ev => {
    if (ev.target.classList.contains('modal')) {
      ev.target.style.display = 'none';
    }
  });

  // --- New Playlist Draggable Logic ---
  const musicCard = document.querySelector('.card.music');
  if (musicCard) {
    const playlistContainer = document.createElement('div');
    playlistContainer.id = 'playlist-container';
    playlistContainer.style.display = 'flex';
    playlistContainer.style.flexDirection = 'column';
    playlistContainer.style.gap = '10px';
    playlistContainer.style.marginTop = '10px';

    const buttons = Array.from(musicCard.querySelectorAll('.play-btn'));
    buttons.forEach(btn => playlistContainer.appendChild(btn));

    musicCard.appendChild(playlistContainer);

    let dragSrcEl = null;

    function handleDragStart(e) {
      dragSrcEl = this;
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', this.outerHTML);
      this.classList.add('dragging');
    }

    function handleDragOver(e) {
      if (e.preventDefault) e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function handleDrop(e) {
      if (e.stopPropagation) e.stopPropagation();
      if (dragSrcEl !== this) {
        const playlist = this.parentNode;
        playlist.removeChild(dragSrcEl);
        const dropHTML = e.dataTransfer.getData('text/html');
        this.insertAdjacentHTML('beforebegin', dropHTML);
        const dropped = this.previousSibling;
        addDnDHandlers(dropped);
      }
      return false;
    }

    function handleDragEnd() {
      this.classList.remove('dragging');
    }

    function addDnDHandlers(elem) {
      elem.setAttribute('draggable', 'true');
      elem.addEventListener('dragstart', handleDragStart, false);
      elem.addEventListener('dragover', handleDragOver, false);
      elem.addEventListener('drop', handleDrop, false);
      elem.addEventListener('dragend', handleDragEnd, false);
    }

    buttons.forEach(btn => addDnDHandlers(btn));
  }

  // --- Floating particles ---
  const particleCanvas = document.getElementById('particle-canvas');
  const pCtx = particleCanvas.getContext('2d');
  let particles = [];
  const particleCount = 60;
  let resizeTimeout;
  let animationsEnabled = true;

  function resizeCanvas(){
    particleCanvas.width = window.innerWidth;
    particleCanvas.height = window.innerHeight;
  }
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(resizeCanvas, 100);
  });
  resizeCanvas();

  function initParticles() {
    particles = [];
    for(let i=0;i<particleCount;i++){
      particles.push({
        x: Math.random() * particleCanvas.width,
        y: Math.random() * particleCanvas.height,
        r: Math.random()*2+1,
        dx: (Math.random()-0.5)*0.2,
        dy: (Math.random()-0.5)*0.2,
        alpha: Math.random()*0.5 + 0.2
      });
    }
  }
  initParticles();

  function drawParticles(){
    if(!animationsEnabled) return;
    pCtx.clearRect(0,0,particleCanvas.width,particleCanvas.height);
    particles.forEach(p=>{
      pCtx.beginPath();
      pCtx.arc(p.x,p.y,p.r,0,Math.PI*2);
      pCtx.fillStyle = `rgba(255,255,255,${p.alpha})`;
      pCtx.fill();
      p.x += p.dx; p.y += p.dy;
      if(p.x<0) p.x=particleCanvas.width; if(p.x>particleCanvas.width)p.x=0;
      if(p.y<0)p.y=particleCanvas.height; if(p.y>particleCanvas.height)p.y=0;
    });
    requestAnimationFrame(drawParticles);
  }
  drawParticles();

  // --- Card flip & subtle floating effect ---
  const cards = document.querySelectorAll('.card');
  cards.forEach(card=>{
    const front = document.createElement('div');
    front.className = 'card-front';
    while(card.firstChild) front.appendChild(card.firstChild);
    card.appendChild(front);

    const back = document.createElement('div');
    back.className = 'card-back';
    back.textContent = 'Extra info can go here!';
    card.appendChild(back);

    card.addEventListener('click', ()=>{
      if(!animationsEnabled) return;
      card.classList.toggle('flip');
    });

    let angle = Math.random()*Math.PI*2;
    let radius = Math.random()*2+1;
    function floatCard(){
      if(!animationsEnabled){ card.style.transform=''; requestAnimationFrame(floatCard); return;}
      angle += 0.01;
      const x = Math.sin(angle)*radius;
      const y = Math.cos(angle)*radius;
      card.style.transform += ` translate(${x}px,${y}px)`;
      requestAnimationFrame(floatCard);
    }
    floatCard();
  });

  // --- No animations toggle ---
  const toggleBtn = document.getElementById('toggle-animations');
  toggleBtn.addEventListener('click', ()=>{
    animationsEnabled = !animationsEnabled;
    document.body.classList.toggle('no-animations', !animationsEnabled);
    if(!animationsEnabled){
      cards.forEach(c=>c.style.transform='');
    }
  });

})();
</script>

<!-- Seal follower integrated directly -->
<script>
(() => {
  // --- Seal follower logic ---
  let seal = document.getElementById('seal-follow');
  if (!seal) {
    seal = document.createElement('img');
    seal.id = 'seal-follow';
    seal.src = 'niko.webp';
    seal.style.position = 'fixed';
    seal.style.width = '50px';
    seal.style.height = '50px';
    seal.style.borderRadius = '50%';
    seal.style.pointerEvents = 'none';
    seal.style.zIndex = '10000';
    document.body.appendChild(seal);
  }

  let sealX = 0, sealY = 0;
  const maxDist = 50; // max distance per frame

  window.addEventListener('mousemove', e => {
    const dx = e.clientX - sealX;
    const dy = e.clientY - sealY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const ratio = dist > maxDist ? maxDist / dist : 1;
    sealX += dx * 0.2 * ratio;
    sealY += dy * 0.2 * ratio;
    seal.style.transform = `translate(${sealX}px,${sealY}px)`;
  });

  // --- Stop cards from flipping ---
  const cards = document.querySelectorAll('.card');
  cards.forEach(card => {
    card.addEventListener('click', e => {
      e.stopPropagation(); // prevent flip
    });
  });
})();
</script>
<!-- Seal follower integrated directly with smooth movement -->
<script>
(() => {
  // --- Seal follower logic ---
  const seal = document.createElement('img');
  seal.id = 'seal-follow';
  seal.src = 'niko.webp';
  seal.style.position = 'fixed';
  seal.style.top = '0px';
  seal.style.left = '0px';
  seal.style.width = '50px';
  seal.style.height = '50px';
  seal.style.borderRadius = '50%';
  seal.style.pointerEvents = 'none';
  seal.style.zIndex = '10000';
  seal.style.transform = 'translate3d(0px, 0px, 0px)';
  document.body.appendChild(seal);

  let sealX = 0, sealY = 0;
  let targetX = 0, targetY = 0;
  const speed = 0.1; // smoothing factor

  window.addEventListener('mousemove', e => {
    targetX = e.clientX - 25; // center the seal
    targetY = e.clientY - 25;
  });

  function animateSeal() {
    sealX += (targetX - sealX) * speed;
    sealY += (targetY - sealY) * speed;
    seal.style.transform = `translate3d(${sealX}px, ${sealY}px, 0)`;
    requestAnimationFrame(animateSeal);
  }
  animateSeal();

  // --- Stop cards from flipping when interacting with seal ---
  const cards = document.querySelectorAll('.card');
  cards.forEach(card => {
    card.addEventListener('click', e => {
      e.stopPropagation(); // prevent any flip on click
    });
  });
})();
</script>
<script>
(() => {
  // --- Drag Sticky Notes (fixed size) ---
  const notes = document.querySelectorAll('.sticky-note');
  notes.forEach(note => {
    let offsetX, offsetY, isDragging = false;
    const noteWidth = note.offsetWidth;
    const noteHeight = note.offsetHeight;

    note.addEventListener('mousedown', e => {
      isDragging = true;
      const rect = note.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
      note.style.transition = 'none';
      note.style.width = noteWidth + 'px';
      note.style.height = noteHeight + 'px';
    });

    window.addEventListener('mousemove', e => {
      if (!isDragging) return;
      note.style.left = `${e.clientX - offsetX}px`;
      note.style.top = `${e.clientY - offsetY}px`;
    });

    window.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        note.style.transition = '';
      }
    });
  });

  // --- Visualizer hover: cycle all colors ---
  const visualizers = document.querySelectorAll('.visualizer');
  visualizers.forEach(canvas => {
    canvas.dataset.hovered = 'false';
    canvas.addEventListener('mouseenter', () => canvas.dataset.hovered = 'true');
    canvas.addEventListener('mouseleave', () => canvas.dataset.hovered = 'false');
  });

  // Monkey-patch drawCenteredBars for dynamic color cycling
  const originalDrawCenteredBars = window.drawCenteredBars;
  window.drawCenteredBars = function(analyser, canvas) {
    const ctx = canvas.getContext('2d');
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    let hue = 0;

    function loop() {
      requestAnimationFrame(loop);
      analyser.getByteFrequencyData(dataArray);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const barWidth = 10;
      const gap = 5;
      const totalWidth = bufferLength * (barWidth + gap);
      const startX = (canvas.width / (window.devicePixelRatio || 1) - totalWidth) / 2;
      let x = startX;

      hue = (hue + 1) % 360; // cycle hue

      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i];
        const h = (v / 255) * (canvas.height / (window.devicePixelRatio || 1) - 8);
        if(canvas.dataset.hovered === 'true') {
          ctx.fillStyle = `hsl(${(hue + i*10) % 360}, 100%, 50%)`; // dynamic rainbow
        } else {
          ctx.fillStyle = '#38e3be'; // normal color
        }
        ctx.fillRect(x, (canvas.height / (window.devicePixelRatio || 1)) - h - 2, barWidth, h);
        x += barWidth + gap;
      }
    }
    loop();
  };
})();
</script>
<script>
(() => {
  // --- Keyboard secret code to show sticky notes ---
  const secretCode = ['s','e','a','l'];
  let codeIndex = 0;

  window.addEventListener('keydown', e => {
    const key = e.key.toLowerCase();
    if (key === secretCode[codeIndex]) {
      codeIndex++;
      if (codeIndex === secretCode.length) {
        // Reveal sticky notes
        document.querySelectorAll('.sticky-note').forEach(note => note.style.display = 'block');
        codeIndex = 0; // reset code sequence
      }
    } else {
      codeIndex = 0; // reset if wrong key
    }
  });

  // --- Initially hide sticky notes for this secret feature ---
  document.querySelectorAll('.sticky-note').forEach(note => note.style.display = 'none');

})();
</script>

</body>
</html>
